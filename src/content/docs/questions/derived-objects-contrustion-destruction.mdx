---
title: Производные объекты
description: Все о конструировании и разрушении производных объектов
sidebar:
  order: 25
---

import { Aside, Tab, Tabs } from '@astrojs/starlight/components'

<Aside>
При создании производного объекта сначала вызываются конструкторы базового класса, затем производного. При уничтожении объект ведет себя наоборот: сначала вызываются деструкторы производного класса, затем базового.
</Aside>

## Введение
Производные объекты в C++ наследуют свойства и методы базового класса. Конструирование и уничтожение таких объектов происходит в определенном порядке, который гарантирует корректную инициализацию и освобождение ресурсов.

## Конструирование производных объектов

### Порядок вызова конструкторов
При создании производного объекта сначала вызывается конструктор базового класса, затем конструктор производного класса. Это гарантирует, что все члены базового класса будут инициализированы до начала инициализации членов производного класса.

### Пример: Конструирование производного объекта
```cpp
#include <iostream>

class Base {
public:
    Base() {
        std::cout << "Base constructor called" << std::endl;
    }
    ~Base() {
        std::cout << "Base destructor called" << std::endl;
    }
};

class Derived : public Base {
public:
    Derived() {
        std::cout << "Derived constructor called" << std::endl;
    }
    ~Derived() {
        std::cout << "Derived destructor called" << std::endl;
    }
};

int main() {
    Derived d;
    return 0;
}
```

### Вывод
```
Base constructor called
Derived constructor called
Derived destructor called
Base destructor called
```
В этом примере при создании объекта `d` класса `Derived` сначала вызывается конструктор базового класса `Base`, а затем конструктор производного класса `Derived`. При уничтожении объекта сначала вызывается деструктор производного класса, затем деструктор базового класса.

## Инициализация членов производного класса

### Инициализация через список инициализации
Члены производного класса могут быть инициализированы с помощью списка инициализации, который также используется для инициализации членов базового класса.

### Пример: Инициализация членов базового и производного классов
```cpp
#include <iostream>

class Base {
public:
    int baseValue;
    Base(int value) : baseValue(value) {
        std::cout << "Base constructor called with value " << baseValue << std::endl;
    }
};

class Derived : public Base {
public:
    int derivedValue;
    Derived(int baseVal, int derivedVal) : Base(baseVal), derivedValue(derivedVal) {
        std::cout << "Derived constructor called with value " << derivedValue << std::endl;
    }
};

int main() {
    Derived d(10, 20);
    return 0;
}
```

### Вывод
```
Base constructor called with value 10
Derived constructor called with value 20
```
В этом примере список инициализации используется для передачи значений конструкторам базового и производного классов.

## Уничтожение производных объектов

### Порядок вызова деструкторов
При уничтожении производного объекта сначала вызывается деструктор производного класса, затем деструктор базового класса. Это гарантирует, что все ресурсы, выделенные производным классом, будут освобождены перед освобождением ресурсов базового класса.

### Важные замечания

- Деструкторы должны быть виртуальными в базовом классе, если предполагается использование полиморфизма, чтобы гарантировать правильный вызов деструкторов производных классов.
- Если в производном классе выделяются ресурсы (например, динамическая память), их необходимо корректно освобождать в деструкторе.

### Пример: Виртуальные деструкторы
```cpp
#include <iostream>

class Base {
public:
    Base() {
        std::cout << "Base constructor called" << std::endl;
    }
    virtual ~Base() {
        std::cout << "Base destructor called" << std::endl;
    }
};

class Derived : public Base {
public:
    Derived() {
        std::cout << "Derived constructor called" << std::endl;
    }
    ~Derived() {
        std::cout << "Derived destructor called" << std::endl;
    }
};

int main() {
    Base* b = new Derived();
    delete b;
    return 0;
}
```

### Вывод
```
Base constructor called
Derived constructor called
Derived destructor called
Base destructor called
```
В этом примере виртуальный деструктор базового класса гарантирует, что при удалении объекта через указатель базового класса будет вызван деструктор производного класса.

## Резюме

- **Конструирование производного объекта**: сначала вызываются конструкторы базового класса, затем производного.
- **Уничтожение производного объекта**: сначала вызываются деструкторы производного класса, затем базового.
- **Инициализация через список инициализации**: используется для передачи значений конструкторам базового и производного классов.
- **Виртуальные деструкторы**: важны для корректного освобождения ресурсов в полиморфных структурах.
